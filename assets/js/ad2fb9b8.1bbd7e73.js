"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[949],{6060:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>h});var o=e(4848),a=e(8453);const i={slug:"nft-auction-ownership",title:"How to check ownership of an NFT in an Auction?",authors:["phoenixpulsar"]},r=void 0,c={permalink:"/blog/nft-auction-ownership",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-12-28-nft-auction-ownership/index.md",source:"@site/blog/2021-12-28-nft-auction-ownership/index.md",title:"How to check ownership of an NFT in an Auction?",description:"",date:"2021-12-28T00:00:00.000Z",tags:[],readingTime:5.105,hasTruncateMarker:!1,authors:[{name:"Phoenix Pulsar",title:"Technomancer of Code and Connection",url:"https://github.com/phoenixpulsar",page:{permalink:"/blog/authors/phoenixpulsar"},socials:{x:"https://x.com/pulsar_phoenix",github:"https://github.com/phoenixpulsar"},imageURL:"https://github.com/phoenixpulsar.png",key:"phoenixpulsar"}],frontMatter:{slug:"nft-auction-ownership",title:"How to check ownership of an NFT in an Auction?",authors:["phoenixpulsar"]},unlisted:!1,nextItem:{title:"Do things live in the blockchain forever?",permalink:"/blog/block-forever"}},s={authorsImageUrls:[void 0]},h=[];function l(n){const t={code:"code",pre:"pre",...(0,a.R)(),...n.components};return(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-md",children:"# 1. Context: An Auction Contract That Sells NFTs\n\n## Auction Contract Overview\n\n- Typically, an auction contract allows users to bid on some item (in this case, an NFT) over a set period.\n- At the end of the auction, the highest bidder wins and should receive the NFT.\n\n### Implicit Assumption\n\n- The auction contract **should** have the right to transfer the NFT from itself to the winning bidder.\n- This means that, ideally, the auction contract actually owns (or controls) the NFT during the auction.\n\n---\n\n# 2. The Problem: No On-Chain Check for Ownership\n\n## What\u2019s Missing?\n\n- In the given scenario, the contract does **not** verify whether it truly owns (or is approved to transfer) the NFT it\u2019s auctioning.\n- There is no function call or logic that checks \u201cDoes this contract really own NFT X?\u201d before letting people bid.\n\n## How a Bad Actor Exploits This\n\n- A malicious user (the \u201cbad actor\u201d) can create or initialize an auction listing an NFT that the contract doesn\u2019t own.\n  - For example, they specify \u201cToken ID = 123 from NFT Contract XYZ,\u201d but the auction contract never actually possessed token **123**.\n- The contract starts accepting bids from unsuspecting bidders.\n\n### When the Auction Ends\n\n- The winning bidder expects the auction contract to transfer the NFT.\n- The contract attempts an `nft_transfer` to the winner.\n- But because the auction contract is not actually the owner (and was never approved), this `nft_transfer` call fails.\n\n### Impact on the Winning Bidder\n\n- The winning bidder has already paid their bid amount into the auction contract (in NEAR tokens or whatever the currency is).\n- Now they receive no NFT in return.\n- The contract might not have any built-in refund mechanism for a failed transfer, so the bidder could lose their funds.\n\n---\n\n# 3. Why Not Just Check On-Chain?\n\n## The Naive \u201cIdeal\u201d Fix\n\n- One straightforward solution would be:\n  1. **Upon auction creation**, call the NFT contract (via cross-contract call) to verify that `owner_id == auction_contract` or that `auction_contract` is approved for the token.\n  2. If the check fails, reject the auction creation.\n\n## Complexity of Cross-Contract Calls\n\n- Cross-contract calls add more complexity:\n  - You need to handle asynchronous callbacks, error states, etc.\n  - It increases the amount of gas usage, plus you must carefully handle reverts or partial failures.\n  - If you\u2019re building multiple checks for different NFTs, the logic can become quite extensive.\n\n---\n\n# 4. The Interim Solution: Off-Chain Validation\n\n## Frontend or Off-Chain Logic\n\n- Instead of making the contract do the ownership verification, the developer can implement a check in their web app or server that:\n  - Calls the NFT contract\u2019s `nft_token(token_id)` method (or an equivalent) to see who currently owns that NFT.\n  - Validates that the current owner is actually the auction contract (or that the auction contract is at least approved to transfer the NFT).\n\n## Reject Invalid Auctions Before Bidding\n\n- If the check reveals the contract doesn\u2019t truly own or control the NFT, the frontend can prevent anyone from placing a bid.\n- This way, legitimate users never see or bid on invalid auctions.\n\n## Why This Works\n\n- Although it\u2019s not as trustless as an on-chain check, most real-world dApps already rely heavily on the frontend for user experience.\n- If you only show valid auctions on the user interface, you significantly reduce the chance that someone accidentally bids on a fraudulent auction.\n\n### Trade-Off\n\n- The downside is that if someone interacts with the contract directly via a CLI or another custom interface (skipping your official frontend), they could still place a bid on a fraudulent auction.\n- However, in many dApp ecosystems, 99%+ of users interact via the official UI, so off-chain checks often suffice in practice.\n\n---\n\n# 5. Recap of the Steps\n\n## Auction Creation\n\n- The malicious user calls your auction contract\u2019s `start_auction` method, claiming there\u2019s an NFT with token ID \u201c123\u201d up for sale.\n- The contract does no checks to see if it really owns that NFT.\n\n## Bidding\n\n- Other users see the auction, place bids, and deposit funds into the contract.\n- Everyone believes the NFT is genuinely controlled by the auction contract.\n\n## Auction Ends\n\n- The highest bidder wins.\n- The contract attempts to do an `nft_transfer` of token \u201c123\u201d from itself to the winner.\n\n## Transfer Fails\n\n- The NFT contract says, \u201cYou\u2019re not the owner; you can\u2019t transfer.\u201d\n- The winner gets nothing. Potentially, their funds are stuck.\n\n## Proposed On-Chain Fix (Complex)\n\n- Right when the auction is created, do a cross-contract call to the NFT contract to confirm ownership.\n- If ownership is not confirmed, the auction creation fails.\n\n## Chosen Solution (For Simplicity)\n\n- Perform an **off-chain** ownership check in the frontend.\n- Only display auctions that pass this verification.\n- This prevents most users from ever bidding on a fraudulent auction.\n\n---\n\n# 6. Key Takeaways\n\n## Importance of Ownership Verification\n\n- Always confirm that the contract **actually controls** the NFT before allowing auctions or sales.\n\n## Security vs. Complexity\n\n- On-chain checks are more secure/trustless but more complex. Off-chain checks reduce complexity but rely on a trusted frontend.\n\n## Refunds\n\n- If you do rely on off-chain checks, consider adding a fallback mechanism in your contract that **refunds bidders if the NFT transfer fails**. That way, nobody loses funds if, somehow, an invalid auction slips through.\n\n## Best Practice\n\n- If time and resources allow, implement **both**:\n  1. On-chain checks that prevent fraudulent auctions from even existing, and\n  2. Off-chain checks in the UI for additional caution and user clarity.\n\n---\n\n## Final Summary\n\nIn short, the contract never verifies that it actually owns the NFT being auctioned, leaving a loophole for malicious auctions. Fully solving this on-chain involves writing a cross-contract call to the NFT contract to confirm ownership before starting an auction. Because cross-contract logic can be cumbersome, a simpler (though less trustless) approach is to do ownership checks off-chain (e.g., in the frontend) and only display auctions that are verifiably valid.\n"})})}function u(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>r,x:()=>c});var o=e(6540);const a={},i=o.createContext(a);function r(n){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function c(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),o.createElement(i.Provider,{value:t},n.children)}}}]);